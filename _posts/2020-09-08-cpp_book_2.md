---
layout: post
title: '[C++] 모듈화, 모듈, 네임스페이스, 에러 및 예외처리'
subtitle: 'A tour of C++ 3장(i)'
date: 2020-09-08
author: nerdooit
cover: '/img/ready.png'
tags: C++ C++&nbspBook
lastmod : '2020-09-08 20:48:00'
sitemap :
  changefreq : daily
  priority : 1.0
---

### A tour of C++ 3장(i)
모듈화, 모듈, 네임스페이스, 에러 및 예외처리에 대해 알아보자.

### 모듈화
C++ 프로그램은 독립적으로 개발된 여러 부분들로 구성된다. 구성요소로는 함수, 클래스, 템플릿, 클래스 계층 관계등이 존재한다. 이들을 관리하는데 있어 가장 중요하는 부분은 ***이들 간의 상호작용을 명확하게 정의 하는 것*** 이다. 상호작용을 명확하게 하기 위한 첫 단계는 "인터페이스" 와 "구현" 을 분리하는 것이다. 즉, 우리가 앞서 클래스를 구성할 때 보았던 것과 같이 사용자를 위해 오픈해주는 인터페이스와 인터페이스에서 필요한 동작을 하는 구현 부분으로 나누는 것이 중요하다.

C++에서는 ***선언***을 기반으로 "인터페이스"를 표현한다. ***선언***은 함수나 타입을 사용하는데 필요한 모든 사항을 명시하는 것을 의미한다.

```java
double sqrt(double);

class Vector {
public:
	Vector(int s);
	double& operator[](int i); // 후위 연산자 재정의
	int size();

private:
	double* elem;
	int sz;
};
```

위와 같이 필요한 사항들이 ***선언*** 되고 나면, 핵심은 '어딘가에' 존재하는 함수 몸체 즉, 함수 ***정의***다. 인터페이스 내에서 동작하는 "구현" 부분의 ***정의***를 확인해보자.

```java
double sqrt(double) {
	// 수학시간에 배운 알고리즘이 들어갈 것임. (간략화 :) )
	return (double *dobule);
}

Vector::Vector(int s)
:elem{new double[s]}, sz{s}
{
}

double& Vector::operator[](int i)
{
	return elem[i];
}

int Vector::size()
{
	return sz;
}
```

함수를 비롯한 구성 요소를 여러 번 선언하는 것은 가능하지만, 정의는 오직 한 번만 가능하다. 우리는 선언과 정의로 나누는 것을 모듈화 한다고 하며, 모듈화 작업을 통해 상호작용을 어떻게 잘 할 수 있는지는 뒷장에서 차차 다루도록 하겠다.


### 분할 컴파일
C 와 동일하게 C++에서는 분할 컴파일을 지원하는데, 덕분에 사용자 코드에서 사용할 타입과 함수의 선언만 존재한다면 컴파일이 가능하다. 함수의 구현부는 외부에 있어도 선언부만 있다면 컴파일하는데 문제가 없음으로 프로그램을 "반독립적"인 코드 조각의 집합들로 조직화 할 수 있다.

이러한 분할 컴파일은 컴파일에 소요되는 시간을 최소화하며, 논리적으로 구분되는 프로그램의 분리를 강제화하는 장점이 있다. 구현부를 굳이 알 필요 없기 떄문에 코드를 작성하는 과정에서 에러를 줄 일 수 있다. 이런 컴파일된 코드 조각 (함수)의 묶음을 우리는 "라이브러리" 라고한다.

보통 선언부는 header file(.h)에 담고 구현 부는 cpp file (cc, cpp)에 담는다. 이후 include (인클루드) 작업을 통해 선언부에 정의된 함수를 접근할 수 있도록 한다.

![split_compile](/img/split_compile.png)

위의 그림과 같이, "정의"는 하나인 반면, 선언부는 다수의 파일에서 사용이 가능하다. 구체적으로, vector.h 파일의 정의부에서 정의한 함수같은 경우 user,cc 파일에서도 선언부를 참고해 사용이 가능하다.

```java
g++ vector.cc
g++ user.cc
```

위와 같이 두 개의 .cc 파일은 컴파일 가능한 독립적인 파일이다. 우리는 이런 독립적으로 컴파일 가능한 .cc or .cpp 파일을 변환단위 (translation unit)이라 하며, 수천 개의 변환 단위가 한 프로그램을 구성할 수 있다.

### 모듈 (C++ 20)
프로그램을 여러 부분으로 구성하기 위해서는 수 많은 #include를 이용한 변환단위들이 필요하다. 이런 방법은 아주 오래되었으며, 에러의 소지도 크고 그에 따른 비용도 크다. 예를들어 101개의 변환 단위에서 #include "header.h"를 사용한다고 가정해보자. 만약 header.h 파일에서 변화가 발생한다면 compiler는 101개의 분한 컴파일로 인해 변환 단위를 전부 다시 컴파일 해야한다. 따라서 빌드 시간이 오래걸린다. 이를 해결하기 위해 ccache 등의 유틸리티가 등장해 빌드 속도를 높이려 열을 올리고 있다.
또한 #include 같은 경우 반독립적으로 컴파일 된다. 따라서 다른 header file을 include 하는 과정에 영향을 미치게 되고 이로 인해 에러가 발생한다.

이런 상황들은 당연 올바르지 않고, C에서 이런 방식을 채용한 1972년 이후로 수많은 비용 발생과 버그의 주요원인이 되고 있다.

C++20에서는 이런 문제를 해결하기 위해 module이라는 새로운 언어 기능을 추가했다.

[오랜지 예제 그림을 통한 설명]
[자바 설명]

[코드 설명]

[ 구체화 설명 ]

