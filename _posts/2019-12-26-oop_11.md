---
layout : post
title : "[C++ OOP] Decorator Pattern" 
tags : ["Design Pattern"]
comments: true
---
### Intro
Decorator pattern을 이용해 추억의 1942 게임을 간단하게 구현해보자.

### Console 구현
추억의 1942 게임을 기억하는가?

비행기 사진

위 사진과 같이, 비행기가 상하좌우로 움직이면서 미사일로 적을 공격해 무찌르는 게임이다.
콘솔로 구현을 했다고 가정을 해보자.

```c
#include <iostream>
using namespace std;

class Airplane
{
  int color;
  int speed;
public:
  void Fire() { cout << "air plane ----- target " << endl; }
};

int main()
{
  Airplane ap;
  ap.Fire();
}
```

위의 코드와 같이 콘솔로서 구현을 간단하게 해볼 수 있다.
만약 비행기를 조종하다가 좋은 아이템을 발견해 총알이 한발 더 나갈 수 있다고 한다면 어떻게 구현해야할 것인가?
우리가 이전에 배웠던, State pattern을 이용하면 구현할 수 있을까? NoNO..

State pattern을 이용하면 상태를 바꿀 수 있지만, 지금과 같은 경우 아이템이 하나가 더 추가 되는 것이기 때문에 state pattern을 이용할 수 없다. 즉, 기존의 동작은 유지하고 하나를 더 추가해야한다.

아래의 사진과 같이 정의하기 위해서는 어떻게 구현해야할까?

### 동작 추가 기능 (상속 이용)
기능을 추가하는 것에 대해 가장 쉽게 생각할 수 있는 기능은 ***상속*** 이다.
만약 왼쪽 미사일을 추가로 발생할 수 있는 아이템을 장착했다고 해보자.

```c
class LeftMissile : public Airplane
{
public:
  void Fire()
  {
    Airplane::Fire(); // 기존의 미사일은 유지
    cout << "Left Missile >>>>>>>> Target " << endl;
  }
};

// main 문에 추가
LeftMissle lm;
lm.Fire();
```

