---
layout: post
title: '[C++] 구조체, 클래스, 공용체, 사용자 정의 타입'
subtitle: 'A tour of C++ 2장'
date: 2020-09-01
author: nerdooit
cover: '/img/ready.png'
tags: C++ "C++ Book"
lastmod : '2020-09-01 21:48:00'
sitemap :
  changefreq : daily
  priority : 1.0
---

### A tour of C++ 2장
구조체, 클래스, 공용체, 열거형 클래스 등 사용자 정의 타입에 대해 알아보자.

해당 포스팅 및 책의 소스코드 정리는 [여기]()를 클릭해 다운받아 확인해보기 바란다.

###  C++ 타입
C++ 에서는 기본타입 (int, double etc), const 제한자, 선언 연산으로 생성할 수 있는 ***내장 타입*** 과 추상화 메커니즘을 바탕으로 만들어진 ***사용자 정의 타입*** 2 가지로 나뉜다. ***내장 타입*** 같은 경우 로우레벨에 가깝게 설계 되어졌으며, 전통적으로 하드웨어의 능력을 직접적이고 효율적으로 사용한다. 반면에 프로그래머로 하여금 진보된 어플리케이션 쉽게 작성하게 해주는 하이레벨 기능을 제공하지 않는다. ***사용자 정의 타입*** 같은 경우 프로그래머가 스스로 적절한 표현방식과 연산을 갖춘 타입을 설계하고 구현하며, 간단하고 편리하게 사용할 수 있게 해준다. ***사용자 정의 타입***의 대표적인 예로 "클래스" 와 "열거형"을 들 수 있다.

### 구조체
새로운 타입을 만드는 첫 단계는 필요한 구성요소를 데이터 구조로 조직화 하는 것이다. 데이터 구조를 조직화하는 키워드는 ***struct***가 사용되며 이를 우리는 구조체 타입이라고 부른다.

```c
struct Vector {
  int sz; // 요소의 개수
  double* elem; // 요소를 가리키는 포인터
};
```

위의 소스코드는 ***요소의 개수*** 와 ***요소를 가리키는 포인터*** 로 이루어진 Vector 구조체를 나타낸 것이다. Struct는 사용자가 만든 타입으로 아래와 같이, 코드내에서 사용가능하다.

```c
int main ()
{
  Vector v; // (.) 연산 접근
  v.sz;

  Vector* v1; // (->) 연산 접근
  v1->sz;
}
```

구조체의 요소에 접근하기 위해서는 (.) 연산을 사용하면 된다. 만약 구조체가 pointer 타입으로 정의 될 경우 (->) 연산을 사용해 내부 데이터에 접근이 가능하다.

위의 Vector 구조체 내 존재하는 double 포인터 같은 경우 double 배열을 가리킬 수 있다. double 배열을 가리킬 요소를 추가하는 코드를 보자.

```c
void vector_init(Vector& v, int s)
{
	v.elem = new double[s];
	v.sz =s;
}
```

vector_init 코드 같은 경우 Vector를 참조연산으로 전달하여, 해당 구조체내 정보를 초기화하는 함수이다. elem 포인터 같은경우 new 연산자를 활용해, Heap 영역에 동적 메모리를 할당받은 후 double 배열을 생성한다. new 연산자로 생성된 배열 혹은 객체는 프로그램이 종요되거나 ***delete*** 연산을 통해 소멸할 때까지 유효하다.

```c
// cin을 이용해 s개의 정수를 읽고 그 합을 반환하는 함수
double read_and_sum(int s)
{
  Vector v;
  vector_init(v,s);

  for (int i = 0; i != s; ++i)
    cin >> v.elem[i];

  double sum = 0;

  for (int i = 0; i != s; ++i)
    sum += v.elem[i];

  return sum;
}
```

위의 코드는 간단하게 숫자를 인자로 전달받아, 전달받은 인자의 갯수만큼 double 버퍼할당하고 채워서 총합을 구하는 함수이다. 우리가 사용할 수 있는 표준 입력 출력을 이용해 간단하게 구현해 볼 수 있다. (직접 작성해서 해보기 바란다.)

### 클래스
***사용자 정의 타입*** 을 좀 더 실세계와 유사하게 하기 위해서는 데이터를 "표현하는 방식"과 "연산" 사이의 개선이 필요하다. 특히, 사용자가 메모리 표현에 접근하지 못하게 함으로 타입 내 데이터의 일관성을 유지하고 쉽게 사용할 수 있도록 할 수 있다는 장점이 있다. 이를 위해 도입된 ***사용자 정의 타입***의 메커니즘이  "클래스" 이다. 클래스는 "타입의 인터페이스" 와 "연산에 필요한 구현"을 분리한다.

클래스는 데이터 뿐만아니라 함수 타입등을 멤버로 가질 수 있다. 연산에 필요한 구현을 사용하는 부분은 외부에서 접근하지 못하도록 하고 외부에서 값을 읽을 필요가 있는 부분은 인터페이스로 만들어 제공한다.

클래스는 외부의 접근을 제한하기 위해 public, private, protected 라는 접근 제한자 3가지를 제공한다.

- public : 일반적으로 누구나 가져다 사용가능 (인터페이스 개념)
- private : 외부에서 접근이 불가능 (구현에 필요한 연산에 사용되는 정보)
- protected : 상속 개념 (추후에 다루도록 한다)

***클래스*** 같은 경우 Default 접근 제한자가 private 이고, ***구조체*** 같은 경우 Default 접근 제한자가 public 이다.






