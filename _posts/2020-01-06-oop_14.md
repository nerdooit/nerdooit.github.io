---
layout : post
title : "[C++ OOP] Observer pattern"
tags : [ "Design Pattern" ]
comments: true
---
### Intro.
하나의 데이터를 변경할 경우 연결된 다양한 객체를 변경하는  Observer pattern에 대해 알아보자.

#### Observer Pattern란
> 객체사이의 1:N의 종속성을 정의하고 하나의 객체로 인해 N개의 종속적인 객체에 통보가 가고 자동적으로 갱신되는 패턴을 "Observer pattern" 이라한다.

위의 개념에서 알 수 있듯 변경에 대한 통보로 인해 연관된 객체의 갱신하는 디자인을 Observer pattern이라 말한다.

간단한 예제를 생각해보자.

![observer1](../images/observer1.png){: width="550" height="450" .center-image}

위의 그림은 우리가 흔히 쓰는 excel 예시를 가져온 것이다. 우리가 excel에서 데이터를 적은 후 시각화하길 원할 때, 삽입 버튼을 누른 후 막대, 원형 등과 같인 그래프를 이용한다. 만약 데이터를 변경할 경우 그래프가 자동적으로 바뀌는 것을 본 적 있을 것이다. 이런 상황을 observer pattern을 이용해 design 되었다 라고 생각하면 된다.

그렇다면 어떻게 해야 데이터를 업데이트 할 경우 모든 그래프가 바뀌게 될 것인가? 우리는 두 가지 방법을 생각해 볼 수 있다.

1. 모든 Graph들이 table의 데이터를 바라보고 있을 경우.
  - 이 경우는 Graph들이 loop를 돌면서, 테이블의 데이터 바뀌는지 유무를 실시간으로 체크해야한다. 만약, 그래프가 수 만개가 된다면? overhead가 너무 커질 수 있다.

2. table이 변경된 후 즉시 Graph들에 통보할 경우.
  - 이 경우는 table에서 Graph를 가리키는 포인터들을 가지고 있으며, 어떤 데이터의 변화가 발생할 경우 모든 Graph에 통보하면 된다.
  - Obsever pattern에서는 이 방법을 사용한다.
    - Graph 같은 객체들을 Observer라고 칭함.
    - Table 같은 객체를 Subject 라고 칭함.

간단하게 excel과 같은 예시를 만들면서 observer pattern을 적용시켜보자.

아래의 코드는 단순한 excel 콘솔 스켈레톤 코드이다.

```c
class Table
{
  int data;
public:
  void SetData(int n) {
    data =n;
  }
};

class PieGraph
{
public:
  void Draw(int n)
  {
    cout << "Pie Graph";
    for (int i = 0; i < n; i++)
      cout << "*";
    cout << endl;
  }
};

class BarGraph
{
public:
  void Draw(int n)
  {
    cout << "Bar Graph";
    for (int i = 0; i < n; i++)
      cout << "+";
    cout << endl;
  }
};
```

#### Simple Obeserver Pattern
단순한 Observer pattern을 이용해 소스코드를 변경해보자.

Table에 데이터가 변경될 경우 Graph들에 "애들아!! 나 지금 데이터 변경 됐어" 라고 알려주면 된다. 그렇다면, Table에서는 Grpah들을 모두 가지고 있어야한다. 이런 Graph들을 관리해 줄 Container가 필요하고 여기서는 vector를 이용할 것이다. Vector를 이용할 경우 어떤 데이터 타입으로 받을 것인가? PieGraph ? BarGraph? 이렇게 받을 경우 특정 Graph만 전달 받을 수 있어서 상위 계층을 만들어야한다. 즉 Upstream을 이용할 수 있는 interface를 구축해야한다.

```c
struct IGraph
{
  virtual void update(int) = 0;

  virtual ~IGraph() {}
};
```

우리는 Table에서 IGraph 인터페이스를 이용해 각 종 그래프들의 정보를 알 수 있다. 단, 모든 Graph는 IGraph를 상속받아 생성해야하는 rule을 정한다.

구조화 시켜 그림을 그려보면 다음과 같다.
![observer](../images/observer_pattern1.png){: .center-image width="550" }

위의 구조화 그림과 같이, Table을 생성한 후 Graph를 생성할 경우 Table에 등록을 해준다. 이후 table의 data가 갱신될 경우 Update함수를 이용해 갱신된 그래프를 그려주도록 한다.

[Simple ObserverPattern 완성된 코드](https://github.com/nerdooit/code_practice/blob/master/Lecture/Design_Pattern/practice/simple_observer.cc)

### Observer Design pattern
Simple 했던 이전의 Observer pattern의 기능을 좀 더 확장시켜보자.

Table 클래스에 초점을 맞추고 생각해보자.
기존의 테이블 같은 경우 int 타입의 data만 다뤘으며, 업데이트 할 경우도 별 문제가 되지 않았다. 만약 data 변경을 많이 해야할 경우는 어떨까?

```c
class Table3D
{
  vector<IGraph*> v;
  int data[10];
public:
  void attach(IGraph* p) { v.push_back(p); }
  void detach()          { v.pop_back(); }

  void SetData(int arr[], int sz) {

    for (int i = 0; i < sz; i++)
    {
      data[i] = arr[i];

      for (auto p : v)
        p->update(data[i]);
    }
  }
};
```

여러개의 데이터를 담는 케이스가 필요해 우리는 클래스를 하나 더 만들었다. Tabel3D 같은 경우 데이터를 여러개 저장할 수 있는 멤버변수를 가지고 있으며, 전달받은 데이터를 저장하는 부분이 약간 복잡해진 케이스다.

우리가 이전에 구현했던 Table 클래스를 보고 어느 부분이 변경되었는지 확인해보자.

```c
class Table
{
  vector<IGraph*> v;
  int data;
public:
  void attach(IGraph* p) { v.push_back(p); }
  void detach()          { v.pop_back(); }

  void setData(int n)
  {
    data = n;

    for (auto p : v)
      p->update(data);
  }
};
```

우리가 처음에 구현한 Table 클래스이다. Table3D 부분과 비교해서 어느 부분이 변경되었는가? Data 부분이 복잡해지고 Data를 저장하는 setData 부분이 복잡해진 것을 우리는 알 수 있다. 이 부분을 보고 유추해볼 수 있는 것이 데이터를 담당하는 부분과 observer 하는 기능부분을 분리해서 생각핼 수 있다는 점이다.

> 데이터가 다양해져 복잡해질 경우, 데이터 담당하는 부분만 변한다. observer기능 하는 부분은 변하지 않는다.

추후에 우리는 
